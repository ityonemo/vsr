searchData={"items":[{"type":"module","title":"Vsr.Message.StartViewChangeAck","doc":"ACK response to START-VIEW-CHANGE","ref":"Vsr.Message.StartViewChangeAck.html"},{"type":"module","title":"Vsr.Message.ViewChangeOk","doc":"VIEW-CHANGE-OK response to new primary","ref":"Vsr.Message.ViewChangeOk.html"},{"type":"behaviour","title":"VsrServer","doc":"GenServer wrapper that implements the VSR (Viewstamped Replication) protocol.\n\nThis module provides a framework for building VSR-enabled services by handling\nall VSR protocol messages while delegating application-specific logic to\nthe implementing module.","ref":"VsrServer.html"},{"type":"behaviour","title":"Overview - VsrServer","doc":"VsrServer implements the core VSR consensus protocol including:\n- Primary-backup replication with automatic failover\n- View changes for fault tolerance\n- Quorum-based consensus decisions\n- Linearizable operation ordering\n- Comprehensive telemetry instrumentation","ref":"VsrServer.html#module-overview"},{"type":"behaviour","title":"Basic Usage - VsrServer","doc":"To create a VSR-enabled service, you need to implement the VsrServer behaviour\nand provide three key components:\n\n1. **State Machine**: Handles application operations\n2. **Communication Layer**: Routes VSR protocol messages between nodes\n3. **Optional Configuration**: Cluster size, timeouts, etc.","ref":"VsrServer.html#module-basic-usage"},{"type":"behaviour","title":"Minimal Example - VsrServer","doc":"```elixir\ndefmodule MyKvStore do\n  use VsrServer\n\n  def start_link(opts) do\n    node_id = Keyword.fetch!(opts, :node_id)\n    cluster_size = Keyword.fetch!(opts, :cluster_size)\n\n    VsrServer.start_link(__MODULE__,\n      node_id: node_id,\n      cluster_size: cluster_size\n    )\n  end\n\n  @impl VsrServer\n  def init(vsr_state) do\n    # Initialize your application state\n    my_state = %{vsr: vsr_state, data: %{}}\n    {:ok, my_state}\n  end\n\n  @impl VsrServer\n  def handle_commit(operation, state) do\n    # Apply committed operation to your state machine\n    case operation do\n      {:write, key, value} ->\n        new_data = Map.put(state.data, key, value)\n        new_state = %{state | data: new_data}\n        {new_state, :ok}\n\n      {:read, key} ->\n        result = Map.get(state.data, key, {:error, :not_found})\n        {state, result}\n    end\n  end\n\n  @impl VsrServer\n  def send_reply(from, reply, state) do\n    # Send reply back to client\n    GenServer.reply(from, reply)\n  end\nend\n```","ref":"VsrServer.html#module-minimal-example"},{"type":"behaviour","title":"State Machine Implementation - VsrServer","doc":"The state machine handles application-specific operations. You must implement:","ref":"VsrServer.html#module-state-machine-implementation"},{"type":"behaviour","title":"Required Callback: handle_commit/2 - VsrServer","doc":"```elixir\n@callback handle_commit(operation :: term, state :: term) ::\n  {new_state :: term, result :: term}\n```\n\nThis callback is invoked when an operation has been committed by the VSR cluster.\nIt should:\n- Apply the operation to your application state\n- Return the updated state and operation result\n- Be deterministic (same operation → same result)\n\nExample:\n```elixir\ndef handle_commit({:increment, key}, state) do\n  current = Map.get(state.counters, key, 0)\n  new_counters = Map.put(state.counters, key, current + 1)\n  new_state = %{state | counters: new_counters}\n  {new_state, {:ok, current + 1}}\nend\n```","ref":"VsrServer.html#module-required-callback-handle_commit-2"},{"type":"behaviour","title":"Communication Layer Implementation - VsrServer","doc":"The communication layer is implemented via the `send_vsr/3` callback on your\nmodule. This callback is invoked whenever VSR needs to send a protocol message\nto another node.","ref":"VsrServer.html#module-communication-layer-implementation"},{"type":"behaviour","title":"Default Implementation (Erlang Distribution) - VsrServer","doc":"The `use VsrServer` macro provides a default implementation that works with\nErlang distribution using `send/2`:\n\n```elixir\ndefmodule MyKvStore do\n  use VsrServer  # Provides default send_vsr implementation\n\n  # ... other callbacks\nend\n```\n\nThe default implementation is:\n\n```elixir\ndef send_vsr(destination, message, _inner_state) do\n  send(destination, {:\"$vsr\", message})\nend\n```\n\nThis works when `node_id` values are:\n- PIDs (e.g., `self()`)\n- Registered names (e.g., `:my_server` or `{:global, :my_server}`)\n- Node names (e.g., `:\"node1@localhost\"` with registered name)","ref":"VsrServer.html#module-default-implementation-erlang-distribution"},{"type":"behaviour","title":"Custom Communication Protocol - VsrServer","doc":"To use a different transport (HTTP, gRPC, JSON-RPC, etc.), override the\n`send_vsr/3` callback:\n\n```elixir\ndefmodule MyHttpKvStore do\n  use VsrServer\n\n  # Override the default send_vsr to use HTTP\n  @impl VsrServer\n  def send_vsr(dest_node_id, vsr_message, _inner_state) do\n    # Serialize VSR message to JSON\n    json_body = Jason.encode!(%{\n      \"type\" => message_type(vsr_message),\n      \"view\" => vsr_message.view,\n      \"data\" => serialize_message(vsr_message)\n    })\n\n    # Send via HTTP POST to the destination node\n    url = \"http://#{dest_node_id}:8080/vsr\"\n    HTTPoison.post(url, json_body, [{\"Content-Type\", \"application/json\"}])\n  end\n\n  defp message_type(%Vsr.Message.Prepare{}), do: \"prepare\"\n  defp message_type(%Vsr.Message.PrepareOk{}), do: \"prepare_ok\"\n  defp message_type(%Vsr.Message.Commit{}), do: \"commit\"\n  # ... other message types\n\n  defp serialize_message(%Vsr.Message.Prepare{} = msg) do\n    %{\n      \"op_number\" => msg.op_number,\n      \"operation\" => msg.operation,\n      \"commit_number\" => msg.commit_number,\n      \"leader_id\" => msg.leader_id\n    }\n  end\n  # ... other serializers\n\n  # ... other callbacks\nend\n```\n\nWhen receiving messages via your custom transport, deserialize and deliver to VsrServer:\n\n```elixir\ndefmodule MyHttpHandler do\n  def handle_vsr_request(conn) do\n    # Deserialize from JSON\n    {:ok, json} = Jason.decode(conn.body_params)\n    vsr_message = deserialize_vsr_message(json)\n\n    # Deliver to local VsrServer\n    VsrServer.vsr_send(conn.assigns.vsr_server, vsr_message)\n\n    # Send HTTP response\n    send_resp(conn, 200, \"ok\")\n  end\n\n  defp deserialize_vsr_message(%{\"type\" => \"prepare\", \"data\" => data} = json) do\n    %Vsr.Message.Prepare{\n      view: json[\"view\"],\n      op_number: data[\"op_number\"],\n      operation: data[\"operation\"],\n      commit_number: data[\"commit_number\"],\n      leader_id: data[\"leader_id\"]\n    }\n  end\n\n  # ... deserialize other message types\nend\n```\n\nThe key insight is that `send_vsr/3` only handles **outgoing** messages.\n**Incoming** messages are delivered via `VsrServer.vsr_send/2` after your\ncustom transport receives and deserializes them.","ref":"VsrServer.html#module-custom-communication-protocol"},{"type":"behaviour","title":"Client Request Handling - VsrServer","doc":"For client requests, use the `send_reply/3` callback to reply back to clients:\n\n```elixir\n@impl VsrServer\ndef send_reply(from, reply, state) do\n  case from do\n    # Standard GenServer from tuple (Erlang distribution)\n    {pid, ref} when is_pid(pid) and is_reference(ref) ->\n      GenServer.reply(from, reply)\n\n    # Custom from (e.g., HTTP request context)\n    %{conn: conn, request_id: req_id} ->\n      send_http_response(conn, req_id, reply)\n\n    # JSON-RPC from\n    %{\"node\" => node_id, \"from\" => client_ref} ->\n      send_json_rpc_reply(node_id, client_ref, reply)\n  end\nend\n```","ref":"VsrServer.html#module-client-request-handling"},{"type":"behaviour","title":"Client Request Deduplication - VsrServer","doc":"VsrServer provides automatic deduplication for client requests using\n`client_id` and `request_id`:\n\n```elixir\n# In your client API\ndef write(vsr_pid, key, value) do\n  client_id = :my_client_1\n  request_id = System.unique_integer([:positive])\n\n  VsrServer.client_request(vsr_pid,\n    {:write, key, value},\n    client_id: client_id,\n    request_id: request_id\n  )\nend\n```\n\nMultiple identical requests (same `client_id` and `request_id`) will:\n- Be processed once\n- All waiting callers receive the same result\n- Prevent duplicate operations","ref":"VsrServer.html#module-client-request-deduplication"},{"type":"behaviour","title":"Configuration Options - VsrServer","doc":"When starting VsrServer, you can configure:\n\n```elixir\nVsrServer.start_link(MyModule,\n  # Required\n  node_id: :node1,                    # Unique identifier for this node\n  cluster_size: 3,                     # Total number of replicas\n\n  # Optional\n  replicas: [:node2, :node3],          # Other replica node IDs (auto-computed if not provided)\n  heartbeat_interval: 100,             # Primary heartbeat interval (ms)\n  heartbeat_timeout: 500,              # Backup timeout for primary failure (ms)\n  name: {:global, :my_vsr_server}      # GenServer registration\n)\n```","ref":"VsrServer.html#module-configuration-options"},{"type":"behaviour","title":"Complete Example: Maelstrom Integration - VsrServer","doc":"See `maelstrom-adapter/` directory for a complete example of implementing\nVSR with a custom JSON-based protocol for Jepsen Maelstrom testing.\n\nKey components:\n- `Maelstrom.Kv` - State machine implementation with custom `send_vsr/3`\n- `Maelstrom.Message` - JSON message serialization\n- `Maelstrom.Stdio` - STDIN/STDOUT message handling\n\nThis demonstrates a complete custom transport implementation without using\nErlang distribution.","ref":"VsrServer.html#module-complete-example-maelstrom-integration"},{"type":"behaviour","title":"Telemetry Events - VsrServer","doc":"VsrServer emits comprehensive telemetry events for monitoring and debugging.\nSee `Vsr.Telemetry` module documentation for complete event reference.\n\nExample telemetry handler:\n\n```elixir\n:telemetry.attach_many(\n  \"vsr-logger\",\n  [\n    [:vsr, :state, :commit_advance],\n    [:vsr, :view_change, :complete],\n    [:vsr, :leadership, :start]\n  ],\n  &handle_vsr_event/4,\n  nil\n)\n\ndef handle_vsr_event(event_name, measurements, metadata, _config) do\n  Logger.info(\"VSR Event: #{inspect(event_name)}\")\nend\n```","ref":"VsrServer.html#module-telemetry-events"},{"type":"behaviour","title":"Error Handling - VsrServer","doc":"VsrServer follows \"let it crash\" philosophy:\n- Invalid messages crash the GenServer (supervised recovery)\n- Network failures are handled by retries/timeouts\n- State machine errors crash and require supervisor restart\n\nFor graceful error handling in your state machine:\n\n```elixir\ndef handle_commit(operation, state) do\n  case validate_operation(operation) do\n    :ok ->\n      # Process operation\n      {new_state, result}\n\n    {:error, reason} ->\n      # Return error result, state unchanged\n      {state, {:error, reason}}\n  end\nend\n```","ref":"VsrServer.html#module-error-handling"},{"type":"behaviour","title":"Testing - VsrServer","doc":"For testing, you can use synchronous operations and inspect state:\n\n```elixir\ntest \"writes are replicated\" do\n  {:ok, replica1} = start_replica(:r1, 3)\n  {:ok, replica2} = start_replica(:r2, 3)\n  {:ok, replica3} = start_replica(:r3, 3)\n\n  # Perform operation\n  result = VsrServer.client_request(replica1, {:write, \"key\", \"value\"})\n  assert result == :ok\n\n  # Check state is replicated\n  state1 = VsrServer.dump(replica1)\n  state2 = VsrServer.dump(replica2)\n\n  assert state1.inner.data[\"key\"] == \"value\"\n  assert state2.inner.data[\"key\"] == \"value\"\nend\n```","ref":"VsrServer.html#module-testing"},{"type":"type","title":"VsrServer.client_request/0","doc":"A client request that expects a reply.  The `from` parameter is typically a `GenServer.from()` term,\nif the cluster communicates using Erlang distribution.  If it does not, you may encode the `from`\nparameter in a way that is appropriate for the communication protocol used by the cluster.","ref":"VsrServer.html#t:client_request/0"},{"type":"type","title":"VsrServer.client_request_noreply/0","doc":"A client request that does not expect a reply.  This should be used sparingly, typically, it is\nbetter to produce a synchronous reply, even if the response is just an `:ok` acknowledgement.","ref":"VsrServer.html#t:client_request_noreply/0"},{"type":"type","title":"VsrServer.node_id/0","doc":"","ref":"VsrServer.html#t:node_id/0"},{"type":"type","title":"VsrServer.server/0","doc":"","ref":"VsrServer.html#t:server/0"},{"type":"opaque","title":"VsrServer.state/0","doc":"","ref":"VsrServer.html#t:state/0"},{"type":"callback","title":"VsrServer.code_change/3","doc":"Invoked to change the state of the `VsrServer` when a different version of a\nmodule is loaded (hot code swapping) and the state's term structure should be\nchanged.\n\nSee `c:GenServer.code_change/3` for general information about this callback.\n\nThis callback is optional.","ref":"VsrServer.html#c:code_change/3"},{"type":"callback","title":"VsrServer.handle_call/3","doc":"Invoked to handle synchronous `call/3` messages.  Generally, initiating operations\non the state machine that VSR wraps should be done through this callback.\n\nSee `c:GenServer.handle_call/3` for general information about this callback.\n\nTo initiate a VSR request, use the `:client_request` tuple.","ref":"VsrServer.html#c:handle_call/3"},{"type":"callback","title":"VsrServer.handle_cast/2","doc":"Invoked to handle asynchronous `cast/2` messages.\n\nSee `c:GenServer.handle_cast/2` for general information about this callback.\n\nTo initiate a VSR request, pass the `:client_request` tuple.  You may use a `from` argument\nin the tuple that has been created by a previous call and stored in the server state.\n\nThis callback is optional. If one is not implemented, the server will fail\nif a cast is performed against it.","ref":"VsrServer.html#c:handle_cast/2"},{"type":"callback","title":"VsrServer.handle_commit/2","doc":"Invoked when a VSR operation is committed and needs to be applied to the state machine.\n\nThis callback receives the operation that was committed, the current inner state,\nand the full VSR state. It should apply the operation and return the new inner state\nand any result value to be sent back to the client.","ref":"VsrServer.html#c:handle_commit/2"},{"type":"callback","title":"VsrServer.handle_continue/2","doc":"Invoked to handle continue instructions.\n\nSee `c:GenServer.handle_info/2` for general information about this callback.\n\nReturn values are the same as `c:handle_cast/2`.\n\nThis callback is optional. If one is not implemented, the server will fail\nif a continue instruction is used.","ref":"VsrServer.html#c:handle_continue/2"},{"type":"callback","title":"VsrServer.handle_info/2","doc":"Invoked to handle all other messages.\n\nSee `c:GenServer.handle_info/2` for general information about this callback.\n\nReturn values are the same as `c:handle_cast/2`.\n\nThis callback is optional. If one is not implemented, the received message\nwill be logged.","ref":"VsrServer.html#c:handle_info/2"},{"type":"callback","title":"VsrServer.init/1","doc":"Invoked when the server is started. `start_link/3` or `start/3` will\nblock until it returns.\n\nSee `c:GenServer.init/1` for general information about the `init/1` callback.\n\nThe `VsrServer` init callback adds an additional `log` term in the success tuple,\nwhich initializes the VSR log,  This should be a durable, local store for logging\nVSR operations.\n\nIf the log must be initialized at a later stage (for example, via an out-of band\ninitialization, then you may return the normal {:ok, state} term)","ref":"VsrServer.html#c:init/1"},{"type":"callback","title":"VsrServer.log_append/2","doc":"Appends an entry to the VSR log.\n\nRequired callback - must be implemented by all VSR modules.","ref":"VsrServer.html#c:log_append/2"},{"type":"callback","title":"VsrServer.log_clear/1","doc":"Clears all entries from the VSR log.\n\nRequired callback - must be implemented by all VSR modules.","ref":"VsrServer.html#c:log_clear/1"},{"type":"callback","title":"VsrServer.log_fetch/2","doc":"Fetches an entry from the VSR log by operation number.\n\nRequired callback - must be implemented by all VSR modules.","ref":"VsrServer.html#c:log_fetch/2"},{"type":"callback","title":"VsrServer.log_get_all/1","doc":"Gets all entries from the VSR log.\n\nRequired callback - must be implemented by all VSR modules.","ref":"VsrServer.html#c:log_get_all/1"},{"type":"callback","title":"VsrServer.log_get_from/2","doc":"Gets entries from the specified operation number onwards.\n\nRequired callback - must be implemented by all VSR modules.","ref":"VsrServer.html#c:log_get_from/2"},{"type":"callback","title":"VsrServer.log_length/1","doc":"Gets the current length (number of entries) in the VSR log.\n\nRequired callback - must be implemented by all VSR modules.","ref":"VsrServer.html#c:log_length/1"},{"type":"callback","title":"VsrServer.log_replace/2","doc":"Replaces the entire VSR log with new entries.\n\nUsed during state transfer and view changes.\nRequired callback - must be implemented by all VSR modules.","ref":"VsrServer.html#c:log_replace/2"},{"type":"callback","title":"VsrServer.monitor_node/3","doc":"Monitors another node in the cluster for failure detection.\n\nThe default implementation uses `Process.monitor/1` for PID-based node identifiers.\nOverride this for custom monitoring mechanisms.","ref":"VsrServer.html#c:monitor_node/3"},{"type":"callback","title":"VsrServer.send_reply/3","doc":"Sends a reply to a client.\n\nThe default implementation uses `GenServer.reply/2` for standard Erlang distribution.\nOverride this for custom communication protocols where the `from` parameter\nneeds to be handled differently (e.g., encoded node references, message passing).","ref":"VsrServer.html#c:send_reply/3"},{"type":"callback","title":"VsrServer.send_vsr/3","doc":"Sends a VSR message to another node in the cluster.\n\nThe default implementation uses PIDs as node identifiers and sends via raw `send/2`.\nOverride this for custom communication protocols (e.g., Maelstrom, network protocols).","ref":"VsrServer.html#c:send_vsr/3"},{"type":"callback","title":"VsrServer.terminate/2","doc":"Invoked when the server is about to exit. It should do any cleanup required.\n\nSee `c:GenServer.terminate/2` for general information about this callback.\n\nThis callback is optional.","ref":"VsrServer.html#c:terminate/2"},{"type":"function","title":"VsrServer.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"VsrServer.html#child_spec/1"},{"type":"function","title":"VsrServer.dump/1","doc":"Dumps the internal state of a VSR server for testing and debugging.","ref":"VsrServer.html#dump/1"},{"type":"function","title":"VsrServer.node_id/1","doc":"Gets the node_id of a VSR server.","ref":"VsrServer.html#node_id/1"},{"type":"function","title":"VsrServer.set_cluster/4","doc":"In the case that the cluster cannot be known at boot time, this function may be used to set cluster details.","ref":"VsrServer.html#set_cluster/4"},{"type":"function","title":"VsrServer.set_log/2","doc":"In the case that the log cannot be known at boot time (for example, some parameter in the log setup depends\non the cluster configuration), this function may be used to set the log.","ref":"VsrServer.html#set_log/2"},{"type":"function","title":"VsrServer.set_log_impl/2","doc":"","ref":"VsrServer.html#set_log_impl/2"},{"type":"function","title":"VsrServer.start_link/2","doc":"","ref":"VsrServer.html#start_link/2"},{"type":"function","title":"VsrServer.vsr_send/2","doc":"In certain situations, you may need to send VSR messages *out-of-band* from the normal erlang distribution\nmechanism that VsrServer relies on by default.  In this case you may use this function to send VSR messages\nto VSR servers.","ref":"VsrServer.html#vsr_send/2"},{"type":"module","title":"Vsr.Message","doc":"VSR protocol message definitions.\n\nAll VSR protocol messages are defined as structs to provide\ntype safety and clear documentation of the protocol.","ref":"Vsr.Message.html"},{"type":"module","title":"Vsr.Message.ClientRequest","doc":"Client request message","ref":"Vsr.Message.ClientRequest.html"},{"type":"module","title":"Vsr.Message.Commit","doc":"COMMIT message sent by primary to backups","ref":"Vsr.Message.Commit.html"},{"type":"module","title":"Vsr.Message.DoViewChange","doc":"DO-VIEW-CHANGE message sent to new primary","ref":"Vsr.Message.DoViewChange.html"},{"type":"module","title":"Vsr.Message.GetState","doc":"GET-STATE request for state transfer","ref":"Vsr.Message.GetState.html"},{"type":"module","title":"Vsr.Message.Heartbeat","doc":"Control message for primary to check replica liveness","ref":"Vsr.Message.Heartbeat.html"},{"type":"module","title":"Vsr.Message.NewState","doc":"NEW-STATE response containing replica state","ref":"Vsr.Message.NewState.html"},{"type":"module","title":"Vsr.Message.Prepare","doc":"PREPARE message sent by primary to backups","ref":"Vsr.Message.Prepare.html"},{"type":"module","title":"Vsr.Message.PrepareOk","doc":"PREPARE-OK response sent by backups to primary","ref":"Vsr.Message.PrepareOk.html"},{"type":"module","title":"Vsr.Message.StartView","doc":"START-VIEW message from new primary to all replicas","ref":"Vsr.Message.StartView.html"},{"type":"module","title":"Vsr.Message.StartViewChange","doc":"START-VIEW-CHANGE message to initiate view change","ref":"Vsr.Message.StartViewChange.html"},{"type":"module","title":"Vsr.LogEntry","doc":"Represents a single entry in the VSR log.\n\nEach entry contains the essential information needed for VSR consensus:\n- view: The view number when this operation was prepared\n- op_number: The operation number (sequence position in log)\n- operation: The actual operation to be applied\n- sender_id: ID of the client that sent this operation (for deduplication)","ref":"Vsr.LogEntry.html"},{"type":"type","title":"Vsr.LogEntry.t/0","doc":"","ref":"Vsr.LogEntry.html#t:t/0"},{"type":"module","title":"Vsr.Telemetry","doc":"Telemetry instrumentation for VSR protocol operations.","ref":"Vsr.Telemetry.html"},{"type":"module","title":"Event Categories - Vsr.Telemetry","doc":"","ref":"Vsr.Telemetry.html#module-event-categories"},{"type":"module","title":"Protocol Operations (:vsr, :protocol, ...) - Vsr.Telemetry","doc":"- `[:vsr, :protocol, :client_request, :start]` - Client request received\n- `[:vsr, :protocol, :client_request, :stop]` - Request completed (committed)\n- `[:vsr, :protocol, :prepare, :sent]` - Prepare message broadcast\n- `[:vsr, :protocol, :prepare, :received]` - Prepare message processed\n- `[:vsr, :protocol, :prepare_ok, :sent]` - PrepareOk ACK sent\n- `[:vsr, :protocol, :prepare_ok, :received]` - PrepareOk ACK received\n- `[:vsr, :protocol, :commit, :sent]` - Commit broadcast\n- `[:vsr, :protocol, :commit, :received]` - Commit processed","ref":"Vsr.Telemetry.html#module-protocol-operations-vsr-protocol"},{"type":"module","title":"State Machine (:vsr, :state_machine, ...) - Vsr.Telemetry","doc":"- `[:vsr, :state_machine, :operation, :start]` - Operation execution started\n- `[:vsr, :state_machine, :operation, :stop]` - Operation completed\n- `[:vsr, :state_machine, :operation, :exception]` - Operation failed","ref":"Vsr.Telemetry.html#module-state-machine-vsr-state_machine"},{"type":"module","title":"View Changes (:vsr, :view_change, ...) - Vsr.Telemetry","doc":"- `[:vsr, :view_change, :start]` - View change initiated\n- `[:vsr, :view_change, :vote_received]` - StartViewChangeAck received\n- `[:vsr, :view_change, :do_view_change, :sent]` - DoViewChange sent to new primary\n- `[:vsr, :view_change, :do_view_change, :received]` - DoViewChange received by primary\n- `[:vsr, :view_change, :complete]` - StartView processed, view established","ref":"Vsr.Telemetry.html#module-view-changes-vsr-view_change"},{"type":"module","title":"State Transitions (:vsr, :state, ...) - Vsr.Telemetry","doc":"- `[:vsr, :state, :status_change]` - Status changed (normal ↔ view_change)\n- `[:vsr, :state, :view_change]` - View number changed\n- `[:vsr, :state, :role_change]` - Primary/replica role changed\n- `[:vsr, :state, :commit_advance]` - Commit number advanced","ref":"Vsr.Telemetry.html#module-state-transitions-vsr-state"},{"type":"module","title":"State Transfer (:vsr, :state_transfer, ...) - Vsr.Telemetry","doc":"- `[:vsr, :state_transfer, :request_sent]` - GetState sent\n- `[:vsr, :state_transfer, :request_received]` - GetState received\n- `[:vsr, :state_transfer, :snapshot_sent]` - NewState sent\n- `[:vsr, :state_transfer, :snapshot_received]` - NewState applied","ref":"Vsr.Telemetry.html#module-state-transfer-vsr-state_transfer"},{"type":"module","title":"Replication Metrics (:vsr, :replication, ...) - Vsr.Telemetry","doc":"- `[:vsr, :replication, :log_append]` - Entry appended to log\n- `[:vsr, :replication, :log_conflict]` - Log conflict detected\n- `[:vsr, :replication, :quorum_reached]` - Quorum achieved for operation","ref":"Vsr.Telemetry.html#module-replication-metrics-vsr-replication"},{"type":"module","title":"Timers (:vsr, :timer, ...) - Vsr.Telemetry","doc":"- `[:vsr, :timer, :heartbeat_sent]` - Heartbeat broadcast\n- `[:vsr, :timer, :heartbeat_received]` - Heartbeat processed\n- `[:vsr, :timer, :primary_timeout]` - Primary inactivity timeout fired","ref":"Vsr.Telemetry.html#module-timers-vsr-timer"},{"type":"module","title":"Metadata - Vsr.Telemetry","doc":"Common metadata included in events:\n- `:node_id` - Node identifier\n- `:view_number` - Current view number\n- `:status` - Current status (:normal, :view_change, etc.)\n- `:is_primary` - Boolean indicating if node is primary\n- `:op_number` - Operation number (when applicable)\n- `:commit_number` - Commit number (when applicable)","ref":"Vsr.Telemetry.html#module-metadata"},{"type":"module","title":"Example Usage - Vsr.Telemetry","doc":"Attach a handler to log all VSR events:\n\n    :telemetry.attach_many(\n      \"vsr-logger\",\n      [\n        [:vsr, :protocol, :client_request, :start],\n        [:vsr, :protocol, :client_request, :stop],\n        [:vsr, :state, :commit_advance]\n      ],\n      fn event, measurements, metadata, _config ->\n        Logger.info(\"VSR Event: #{inspect(event)}\",\n          measurements: measurements,\n          metadata: metadata\n        )\n      end,\n      nil\n    )","ref":"Vsr.Telemetry.html#module-example-usage"},{"type":"function","title":"Vsr.Telemetry.common_metadata/1","doc":"Build common metadata from VSR state.\n\nExtracts standard VSR state fields that are commonly included in telemetry events.","ref":"Vsr.Telemetry.html#common_metadata/1"},{"type":"function","title":"Vsr.Telemetry.execute/4","doc":"Execute a telemetry event with the given measurements and metadata.\n\nThe event name will automatically have `[:vsr]` prepended to it.\n\nCommon metadata (node_id, view_number, etc.) is automatically extracted\nfrom the state and merged with any additional metadata provided.","ref":"Vsr.Telemetry.html#execute/4"},{"type":"function","title":"Examples - Vsr.Telemetry.execute/4","doc":"# Basic usage\n    Vsr.Telemetry.execute(\n      [:protocol, :prepare, :sent],\n      state,\n      %{count: 3}\n    )\n    # Becomes: [:vsr, :protocol, :prepare, :sent]\n\n    # With extra metadata\n    Vsr.Telemetry.execute(\n      [:protocol, :prepare, :sent],\n      state,\n      %{count: 3},\n      %{custom_field: \"value\"}\n    )","ref":"Vsr.Telemetry.html#execute/4-examples"},{"type":"function","title":"Vsr.Telemetry.span/4","doc":"Execute a telemetry span with proper timing measurements and span context.\n\nThe event name will automatically have `[:vsr]` prepended to it.\nThe span will emit both `:start` and `:stop` (or `:exception`) events.\n\nCommon metadata is automatically extracted from state and a unique span context\nis generated using `make_ref()`.","ref":"Vsr.Telemetry.html#span/4"},{"type":"function","title":"Examples - Vsr.Telemetry.span/4","doc":"# Wrap an operation in a telemetry span\n    result = Vsr.Telemetry.span(\n      [:protocol, :client_request],\n      state,\n      %{custom: \"metadata\"},\n      fn ->\n        # Do work\n        :ok\n      end\n    )","ref":"Vsr.Telemetry.html#span/4-examples"},{"type":"function","title":"Events Emitted - Vsr.Telemetry.span/4","doc":"- `[:vsr, :protocol, :client_request, :start]` - When span begins\n- `[:vsr, :protocol, :client_request, :stop]` - When span completes successfully\n- `[:vsr, :protocol, :client_request, :exception]` - When span raises an exception","ref":"Vsr.Telemetry.html#span/4-events-emitted"},{"type":"function","title":"Measurements - Vsr.Telemetry.span/4","doc":"- `:start` event: `monotonic_time`, `system_time`\n- `:stop` event: `monotonic_time`, `duration`\n- `:exception` event: `monotonic_time`, `duration`","ref":"Vsr.Telemetry.html#span/4-measurements"},{"type":"function","title":"Metadata - Vsr.Telemetry.span/4","doc":"All events include:\n- Common metadata from state (node_id, view_number, etc.)\n- `telemetry_span_context` - Unique reference for correlating start/stop events\n- Any additional metadata provided","ref":"Vsr.Telemetry.html#span/4-metadata"},{"type":"extras","title":"Vsr","doc":"# Vsr\n\n**Viewstamped Replication for Elixir**\n\nA distributed consensus system implementing the Viewstamped Replication (VSR) protocol, providing fault-tolerant state machine replication with automatic failure recovery.","ref":"readme.html"},{"type":"extras","title":"Features - Vsr","doc":"✅ **Core VSR Protocol**\n- Primary-backup replication with view changes\n- Automatic primary failure detection and recovery\n- Log-based operation ordering and consistency\n- Quorum-based consensus decisions\n\n✅ **Implemented Components**\n- Sequential operation validation with gap detection\n- Heartbeat mechanism for failure detection\n- Automatic view change triggering on primary timeout\n- Memory management (cleanup of committed operation metadata)\n- Pluggable state machines, log storage, and communication layers\n\n✅ **Observability**\n- Comprehensive telemetry instrumentation following Erlang/Elixir conventions\n- Leadership span tracking (when nodes are primary/leader)\n- Protocol event tracking (prepare, commit, view changes)\n- State machine operation spans with duration metrics\n- Timer and heartbeat event tracking\n- See [TELEMETRY_EVENTS.md](TELEMETRY_EVENTS.md) for complete event documentation","ref":"readme.html#features"},{"type":"extras","title":"Current Limitations - Vsr","doc":"⚠️ **Client Request Deduplication**: Currently only implemented for read-only operations. Write operations may be processed multiple times if clients retry requests due to network timeouts. This does not affect VSR protocol correctness or safety properties, but may impact user experience.\n\n- **Workaround**: Implement request deduplication at the application layer using unique request IDs\n- **Future Work**: Full write operation deduplication requires propagating client identifiers through the entire VSR protocol\n\n⚠️ **No Reconfiguration Support**: The implementation assumes a static cluster with fixed membership. Dynamic addition or removal of replicas (reconfiguration protocol from the VSR paper) is not currently supported.\n\n- **Limitation**: Cluster size and membership must be determined at startup and cannot be changed during operation\n- **Workaround**: Plan cluster capacity ahead of time to accommodate expected load\n- **Future Work**: Implement the reconfiguration protocol described in \"Viewstamped Replication Revisited\"","ref":"readme.html#current-limitations"},{"type":"extras","title":"Installation - Vsr","doc":"If [available in Hex](https://hex.pm/docs/publish), the package can be installed\nby adding `vsr` to your list of dependencies in `mix.exs`:\n\n```elixir\ndef deps do\n  [\n    {:vsr, \"~> 0.1.0\"}\n  ]\nend\n```","ref":"readme.html#installation"},{"type":"extras","title":"Usage - Vsr","doc":"```elixir\n# Start a VSR replica with a key-value state machine\n{:ok, replica} = Vsr.start_link(\n  log: [],\n  state_machine: VsrKv,\n  cluster_size: 3\n)\n\n# Perform operations\nVsrKv.put(replica, \"key\", \"value\")\nresult = VsrKv.get(replica, \"key\")  # Returns \"value\"\n```","ref":"readme.html#usage"},{"type":"extras","title":"Testing - Vsr","doc":"","ref":"readme.html#testing"},{"type":"extras","title":"Unit Tests - Vsr","doc":"```bash\nmix test\n```\n\n**Test Status**: 106/106 tests passing","ref":"readme.html#unit-tests"},{"type":"extras","title":"Jepsen Maelstrom Testing - Vsr","doc":"VSR includes integration with [Jepsen Maelstrom](https://github.com/jepsen-io/maelstrom), a workbench for learning distributed systems by writing your own implementations and testing them against fault injection.\n\n#### Download Maelstrom\n\n1. Download the latest Maelstrom release:\n   ```bash\n   wget https://github.com/jepsen-io/maelstrom/releases/download/v0.2.3/maelstrom.tar.bz2\n   tar -xjf maelstrom.tar.bz2\n   ```\n\n2. Or use the provided script to download and extract:\n   ```bash\n   curl -L https://github.com/jepsen-io/maelstrom/releases/download/v0.2.3/maelstrom.tar.bz2 | tar -xj\n   ```\n\n#### Run Maelstrom Tests\n\nThe repository includes a convenience script for running linearizable key-value tests:\n\n```bash\n./maelstrom-kv\n```\n\nThis runs the `lin-kv` workload which tests:\n- Linearizable key-value operations (read, write, cas)\n- Fault tolerance with network partitions\n- Consistency under concurrent operations\n\n#### Manual Maelstrom Testing\n\nYou can also run Maelstrom tests manually:\n\n```bash\ncd maelstrom\njava -jar maelstrom.jar test \\\n  -w lin-kv \\\n  --bin ../run-vsr-node \\\n  --node-count 3 \\\n  --time-limit 10 \\\n  --concurrency 6\n```\n\n**Workload Options:**\n- `lin-kv` - Linearizable key-value store (read, write, cas operations)\n- `--node-count` - Number of VSR replicas to run\n- `--time-limit` - Duration of test in seconds\n- `--concurrency` - Number of concurrent client operations\n\n#### Interpreting Results\n\nAfter a test run, check:\n\n1. **Test results**: Maelstrom will report if linearizability was maintained\n2. **Logs**: Found in `store/lin-kv/latest/`\n   - `jepsen.log` - Test runner logs and errors\n   - `node-logs/n*.log` - Individual node logs\n\n**Success criteria:**\n- All operations must satisfy linearizability\n- Minimal network timeouts (some expected during partitions)\n- No crashes or protocol violations","ref":"readme.html#jepsen-maelstrom-testing"},{"type":"extras","title":"Architecture - Vsr","doc":"See `SPECIFICATION.md` for detailed VSR protocol specification.\n\nDocumentation can be generated with [ExDoc](https://github.com/elixir-lang/ex_doc)\nand published on [HexDocs](https://hexdocs.pm). Once published, the docs can\nbe found at  .","ref":"readme.html#architecture"},{"type":"extras","title":"Changelog","doc":"# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [0.1.0] - 2025-01-01","ref":"changelog.html"},{"type":"extras","title":"Added - Changelog","doc":"- Initial release of VSR (Viewstamped Replication) protocol implementation\n- Core VSR protocol with primary-backup replication and view changes\n- Automatic primary failure detection and recovery via heartbeat mechanism\n- Log-based operation ordering and consistency\n- Quorum-based consensus decisions\n- Sequential operation validation with gap detection\n- Memory management with cleanup of committed operation metadata\n- Pluggable state machines, log storage, and communication layers\n- Comprehensive telemetry instrumentation following Erlang/Elixir conventions\n  - Leadership span tracking (when nodes are primary/leader)\n  - Protocol event tracking (prepare, commit, view changes)\n  - State machine operation spans with duration metrics\n  - Timer and heartbeat event tracking\n- Client request deduplication with waiter list for duplicate requests\n- Simplified view change protocol (counts StartViewChange messages directly)\n- Jepsen Maelstrom integration for distributed systems testing\n- Example key-value state machine implementations (in-memory and DETS)","ref":"changelog.html#added"},{"type":"extras","title":"Documentation - Changelog","doc":"- Comprehensive README with usage examples and testing instructions\n- SPECIFICATION.md with detailed VSR protocol specification\n- TELEMETRY_EVENTS.md with complete telemetry event documentation\n- Review documentation showing all safety issues addressed","ref":"changelog.html#documentation"},{"type":"extras","title":"Testing - Changelog","doc":"- 106 unit tests covering all protocol operations\n- Maelstrom linearizability testing integration\n- Zero network timeout validation","ref":"changelog.html#testing"},{"type":"extras","title":"Known Limitations - Changelog","doc":"- Client request deduplication only implemented for read operations on write paths\n- No reconfiguration support (static cluster membership)\n\n[0.1.0]: https://github.com/ityonemo/vsr/releases/tag/v0.1.0","ref":"changelog.html#known-limitations"},{"type":"extras","title":"Viewstamped Replication (VSR) Specification","doc":"# Viewstamped Replication (VSR) Specification","ref":"specification.html"},{"type":"extras","title":"Overview - Viewstamped Replication (VSR) Specification","doc":"Viewstamped Replication is a consensus algorithm for building fault-tolerant distributed systems. VSR ensures that a collection of replicas agree on a sequence of operations, even in the presence of failures.","ref":"specification.html#overview"},{"type":"extras","title":"Core Concepts - Viewstamped Replication (VSR) Specification","doc":"","ref":"specification.html#core-concepts"},{"type":"extras","title":"Roles - Viewstamped Replication (VSR) Specification","doc":"- **Primary**: The current leader that processes client requests and coordinates replication\n- **Backup**: Followers that maintain replicated state and can become primary\n- **Client**: External entities that submit operations to the system","ref":"specification.html#roles"},{"type":"extras","title":"View - Viewstamped Replication (VSR) Specification","doc":"A **view** is a configuration period with a designated primary. Views are numbered sequentially starting from 0.\nThe primary for view `v` is determined by: `primary = configuration[v % length(configuration)]`","ref":"specification.html#view"},{"type":"extras","title":"Operation Log - Viewstamped Replication (VSR) Specification","doc":"Each replica maintains an ordered log of operations. Operations are identified by:\n- **View number**: The view in which the operation was proposed\n- **Operation number**: Sequential number within the view\n- **Operation**: The actual operation to execute\n- **Sender ID**: The replica that proposed the operation","ref":"specification.html#operation-log"},{"type":"extras","title":"Replica State - Viewstamped Replication (VSR) Specification","doc":"Each replica maintains:\n```elixir\n%Vsr.Replica{\n  replica_id: integer(),           # Unique identifier for this replica\n  view_number: integer(),          # Current view number\n  status: :normal | :view_change | :recovering,  # Current operational status\n  op_number: integer(),            # Highest operation number seen\n  commit_number: integer(),        # Highest committed operation number\n  log: [log_entry()],             # Ordered list of operations\n  configuration: [integer()],      # List of all replica IDs\n  primary: integer(),             # Current primary replica ID\n  store: term(),                  # State machine storage\n  client_table: term(),           # Client request deduplication\n  prepare_ok_count: %{integer() => integer()},  # Count of prepare-ok per operation\n  view_change_votes: %{integer() => boolean()}, # Votes for view change\n  last_normal_view: integer()     # Last view in normal operation\n}\n```","ref":"specification.html#replica-state"},{"type":"extras","title":"Algorithm Phases - Viewstamped Replication (VSR) Specification","doc":"","ref":"specification.html#algorithm-phases"},{"type":"extras","title":"1. Normal Operation Phase - Viewstamped Replication (VSR) Specification","doc":"#### Client Request Processing\n\n**Message**: Client sends operation to primary\n**Internal State Changes**:\n1. **Primary receives client request**:\n   - Checks if request already processed (client_table lookup)\n   - If duplicate: return cached result\n   - If new: increment `op_number`\n   - Create log entry: `{view_number, op_number, operation, replica_id}`\n   - Append to `log`\n   - Initialize `prepare_ok_count[op_number] = 1` (self-vote)\n\n#### Prepare Phase\n\n**Message**: Primary sends `PREPARE(view, op-num, operation, commit-num)` to all backups\n**Internal State Changes**:\n1. **Backup receives PREPARE**:\n   - Validates `view >= view_number`\n   - If `op_number > length(log)`: append operation to `log`\n   - Update `op_number = max(op_number, received_op_number)`\n   - Send `PREPARE-OK(view, op-num, replica-id)` to primary\n\n2. **Primary receives PREPARE-OK**:\n   - Increment `prepare_ok_count[op_number]`\n   - If `prepare_ok_count[op_number] > majority`:\n     - Update `commit_number = max(commit_number, op_number)`\n     - Apply all operations where `log_op_number <= commit_number` to state machine\n     - Send `COMMIT(view, commit-num)` to all backups\n\n#### Commit Phase\n\n**Message**: Primary sends `COMMIT(view, commit-num)` to backups\n**Internal State Changes**:\n1. **Backup receives COMMIT**:\n   - Validates `view == view_number`\n   - If `commit_number < received_commit_number`:\n     - Update `commit_number = received_commit_number`\n     - Apply all operations where `log_op_number <= commit_number` to state machine\n     - Update client_table with results","ref":"specification.html#1-normal-operation-phase"},{"type":"extras","title":"2. View Change Phase - Viewstamped Replication (VSR) Specification","doc":"#### Detecting Primary Failure\n\n**Trigger**: Backup detects primary timeout or failure\n**Internal State Changes**:\n1. **Backup initiates view change**:\n   - Increment `view_number`\n   - Set `status = :view_change`\n   - Calculate new `primary = configuration[view_number % length(configuration)]`\n   - Initialize `view_change_votes[replica_id] = true`\n   - Send `START-VIEW-CHANGE(view, replica-id)` to all replicas\n\n#### Start View Change Phase\n\n**Message**: `START-VIEW-CHANGE(view, replica-id)` sent to all replicas\n**Internal State Changes**:\n1. **Replica receives START-VIEW-CHANGE**:\n   - If `view > view_number`:\n     - Update `view_number = view`\n     - Set `status = :view_change` \n     - Update `primary = configuration[view % length(configuration)]`\n     - Set `view_change_votes[sender_id] = true`\n     - Send `START-VIEW-CHANGE-ACK(view, replica-id)` to sender\n   - If `count(view_change_votes) > majority`:\n     - Send `DO-VIEW-CHANGE(view, log, last_normal_view, op_number, commit_number, replica-id)` to new primary\n\n#### Do View Change Phase\n\n**Message**: `DO-VIEW-CHANGE(view, log, last_normal_view, op_number, commit_number, replica-id)` sent to new primary\n**Internal State Changes**:\n1. **New primary receives DO-VIEW-CHANGE**:\n   - If `view >= view_number`:\n     - Merge received log with local log (take highest op_number entries)\n     - Update `view_number = view`\n     - Update `log = merged_log`\n     - Update `op_number = max(op_number, received_op_number)`\n     - Update `commit_number = max(commit_number, received_commit_number)`\n     - Set `status = :normal`\n     - Send `START-VIEW(view, log, op_number, commit_number)` to all other replicas\n\n#### Start View Phase\n\n**Message**: `START-VIEW(view, log, op_number, commit_number)` sent from new primary\n**Internal State Changes**:\n1. **Replica receives START-VIEW**:\n   - If `view >= view_number`:\n     - Update `view_number = view`\n     - Replace `log = received_log`\n     - Update `op_number = received_op_number`\n     - Update `commit_number = received_commit_number`\n     - Set `status = :normal`\n     - Update `primary = configuration[view % length(configuration)]`\n     - Apply all committed operations to state machine\n     - Send `VIEW-CHANGE-OK(view, replica-id)` to new primary\n\n#### View Change Completion\n\n**Message**: `VIEW-CHANGE-OK(view, replica-id)` sent to new primary\n**Internal State Changes**:\n1. **New primary receives VIEW-CHANGE-OK**:\n   - Set `view_change_votes[sender_id] = true`\n   - If `count(view_change_votes) > majority`:\n     - Clear `view_change_votes = %{}`\n     - Set `last_normal_view = view`\n     - Resume normal operation","ref":"specification.html#2-view-change-phase"},{"type":"extras","title":"3. State Transfer Phase - Viewstamped Replication (VSR) Specification","doc":"#### Requesting State\n\n**Message**: Lagging replica sends `GET-STATE(view, op_number, replica-id)` to primary\n**Internal State Changes**:\n1. **Lagging replica initiates**:\n   - Detect it's behind (lower op_number or view_number)\n   - Send `GET-STATE(view_number, op_number, replica_id)` to primary\n\n2. **Primary receives GET-STATE**:\n   - Package current state: `{view_number, log, op_number, commit_number}`\n   - Send `NEW-STATE(view, log, op_number, commit_number)` to requester\n\n#### Receiving State\n\n**Message**: `NEW-STATE(view, log, op_number, commit_number)` sent from primary\n**Internal State Changes**:\n1. **Lagging replica receives NEW-STATE**:\n   - If `view >= view_number OR op_number > local_op_number`:\n     - Update `view_number = received_view`\n     - Replace `log = received_log`\n     - Update `op_number = received_op_number`\n     - Update `commit_number = received_commit_number`\n     - Set `status = :normal`\n     - Apply all committed operations to state machine\n     - Resume normal operation","ref":"specification.html#3-state-transfer-phase"},{"type":"extras","title":"Message Types - Viewstamped Replication (VSR) Specification","doc":"","ref":"specification.html#message-types"},{"type":"extras","title":"Normal Operation Messages - Viewstamped Replication (VSR) Specification","doc":"- `PREPARE(view, op-num, operation, commit-num)`\n- `PREPARE-OK(view, op-num, replica-id)`\n- `COMMIT(view, commit-num)`","ref":"specification.html#normal-operation-messages"},{"type":"extras","title":"View Change Messages - Viewstamped Replication (VSR) Specification","doc":"- `START-VIEW-CHANGE(view, replica-id)`\n- `START-VIEW-CHANGE-ACK(view, replica-id)`\n- `DO-VIEW-CHANGE(view, log, last_normal_view, op_number, commit_number, replica-id)`\n- `START-VIEW(view, log, op_number, commit_number)`\n- `VIEW-CHANGE-OK(view, replica-id)`","ref":"specification.html#view-change-messages"},{"type":"extras","title":"State Transfer Messages - Viewstamped Replication (VSR) Specification","doc":"- `GET-STATE(view, op_number, replica-id)`\n- `NEW-STATE(view, log, op_number, commit_number)`","ref":"specification.html#state-transfer-messages"},{"type":"extras","title":"Client Messages - Viewstamped Replication (VSR) Specification","doc":"- `REQUEST(operation, client-id, request-id)`\n- `REPLY(request-id, result)`","ref":"specification.html#client-messages"},{"type":"extras","title":"Safety Properties - Viewstamped Replication (VSR) Specification","doc":"1. **Agreement**: All replicas execute the same operations in the same order\n2. **Integrity**: A replica executes an operation at most once\n3. **Validity**: Only proposed operations are executed","ref":"specification.html#safety-properties"},{"type":"extras","title":"Liveness Properties - Viewstamped Replication (VSR) Specification","doc":"1. **Termination**: Every operation eventually executes (assuming eventual synchrony)\n2. **View Change**: System eventually selects a new primary when current primary fails","ref":"specification.html#liveness-properties"},{"type":"extras","title":"State Machine Integration - Viewstamped Replication (VSR) Specification","doc":"The VSR protocol is agnostic to the underlying state machine. Operations are applied in order to maintain consistency:\n\n```elixir\ndefprotocol Vsr.StateMachine do\n  @doc \"Apply an operation to the state machine\"\n  def _apply_operation(state_machine, operation)\n  \n  @doc \"Get current state for state transfer\"\n  def _get_state(state_machine)\n  \n  @doc \"Set state during state transfer\"\n  def _set_state(state_machine, state)\nend\n```","ref":"specification.html#state-machine-integration"},{"type":"extras","title":"Log Storage Abstraction - Viewstamped Replication (VSR) Specification","doc":"The operation log can be implemented with different backends:\n\n```elixir\ndefprotocol Vsr.Log do\n  @doc \"Append operation to log\"\n  def append(log, view, op_number, operation, sender_id)\n  \n  @doc \"Get operation at index\"\n  def get(log, index)\n  \n  @doc \"Get all operations\"\n  def get_all(log)\n  \n  @doc \"Get operations from index onwards\"\n  def get_from(log, index)\n  \n  @doc \"Get log length\"\n  def length(log)\nend\n```","ref":"specification.html#log-storage-abstraction"},{"type":"extras","title":"Correctness Conditions - Viewstamped Replication (VSR) Specification","doc":"1. **View Synchronization**: All replicas agree on current view\n2. **Log Consistency**: Replica logs are consistent up to commit point\n3. **Primary Completeness**: New primary has all committed operations\n4. **Monotonicity**: View numbers and operation numbers never decrease\n\nThis specification provides the foundation for implementing a correct and efficient VSR-based distributed system with clear understanding of internal state transitions.","ref":"specification.html#correctness-conditions"},{"type":"extras","title":"Telemetry Events","doc":"# Telemetry Events\n\nVSR emits comprehensive telemetry events following Erlang/Elixir telemetry conventions. All events are prefixed with `[:vsr]`.","ref":"telemetry_events.html"},{"type":"extras","title":"Event Categories - Telemetry Events","doc":"- [Leadership Span](#leadership-span)\n- [Protocol Events](#protocol-events)\n- [State Changes](#state-changes)\n- [View Changes](#view-changes)\n- [State Machine Operations](#state-machine-operations)\n- [Timer Events](#timer-events)\n\n---","ref":"telemetry_events.html#event-categories"},{"type":"extras","title":"Leadership Span - Telemetry Events","doc":"Tracks when a node is the primary/leader in the VSR cluster.\n\n### `[:vsr, :leadership, :start]`\n\nEmitted when a node becomes the primary.\n\n**Measurements:**\n- `system_time` - System time when leadership started\n- `monotonic_time` - Monotonic time when leadership started\n\n**Metadata:**\n- `telemetry_span_context` - Unique reference for correlating start/stop events\n- `node_id` - The node's identifier\n- `view_number` - Current view number\n- `status` - Current node status\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number\n- `commit_number` - Current commit number\n\n**When emitted:**\n- During initial startup if the node is primary for view 0\n- After completing a view change when becoming the new primary\n\n### `[:vsr, :leadership, :stop]`\n\nEmitted when a node loses leadership.\n\n**Measurements:**\n- `monotonic_time` - Monotonic time when leadership ended\n- `duration` - Duration of leadership (currently 0, to be calculated in future versions)\n\n**Metadata:**\n- `telemetry_span_context` - Same reference from the corresponding `:start` event\n- `node_id` - The node's identifier\n- `view_number` - View number when leadership was lost\n- `status` - Node status when leadership was lost\n- `cluster_size` - Total cluster size\n- `op_number` - Operation number when leadership was lost\n- `commit_number` - Commit number when leadership was lost\n\n**When emitted:**\n- During view changes when transitioning from primary to backup\n\n---","ref":"telemetry_events.html#leadership-span"},{"type":"extras","title":"Protocol Events - Telemetry Events","doc":"### `[:vsr, :protocol, :client_request, :start]`\n\nEmitted when a primary node starts processing a client request.\n\n**Measurements:**\n- `count` - Always 1\n\n**Metadata:**\n- `operation` - String representation of the operation\n- `client_id` - Client identifier (if provided for deduplication)\n- `request_id` - Request identifier (if provided for deduplication)\n- `node_id` - The node's identifier\n- `view_number` - Current view number\n- `status` - Current node status\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number\n- `commit_number` - Current commit number\n\n### `[:vsr, :protocol, :prepare, :sent]`\n\nEmitted when a primary broadcasts PREPARE messages to replicas.\n\n**Measurements:**\n- `count` - Number of replicas the prepare was sent to\n\n**Metadata:**\n- `node_id` - The node's identifier\n- `view_number` - Current view number\n- `status` - Current node status\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number\n- `commit_number` - Current commit number\n\n### `[:vsr, :protocol, :prepare, :received]`\n\nEmitted when a backup receives a PREPARE message.\n\n**Measurements:**\n- `count` - Always 1\n\n**Metadata:**\n- `prepare_view` - View number from the prepare message\n- `prepare_op_number` - Operation number from the prepare message\n- `sender` - Node ID of the sender (leader)\n- `node_id` - The node's identifier\n- `view_number` - Current view number\n- `status` - Current node status\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number\n- `commit_number` - Current commit number\n\n### `[:vsr, :protocol, :prepare_ok, :sent]`\n\nEmitted when a backup sends a PREPARE-OK message to the primary.\n\n**Measurements:**\n- `count` - Always 1\n\n**Metadata:**\n- `prepare_ok_view` - View number in the prepare-ok\n- `prepare_ok_op_number` - Operation number in the prepare-ok\n- `node_id` - The node's identifier\n- `view_number` - Current view number\n- `status` - Current node status\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number\n- `commit_number` - Current commit number\n\n### `[:vsr, :protocol, :prepare_ok, :received]`\n\nEmitted when a primary receives a PREPARE-OK message.\n\n**Measurements:**\n- `count` - Always 1\n\n**Metadata:**\n- `prepare_ok_view` - View number from the prepare-ok\n- `prepare_ok_op_number` - Operation number from the prepare-ok\n- `sender` - Node ID of the sender (backup)\n- `node_id` - The node's identifier\n- `view_number` - Current view number\n- `status` - Current node status\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number\n- `commit_number` - Current commit number\n\n### `[:vsr, :protocol, :commit, :sent]`\n\nEmitted when a primary broadcasts COMMIT messages.\n\n**Measurements:**\n- `count` - Number of replicas the commit was sent to\n\n**Metadata:**\n- `commit_view` - View number in the commit message\n- `commit_number` - Commit number in the commit message\n- `node_id` - The node's identifier\n- `view_number` - Current view number\n- `status` - Current node status\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number\n- `commit_number` - Current commit number (before the new commit)\n\n### `[:vsr, :protocol, :commit, :received]`\n\nEmitted when a backup receives a COMMIT message.\n\n**Measurements:**\n- `count` - Always 1\n\n**Metadata:**\n- `commit_view` - View number from the commit message\n- `commit_number` - Commit number from the commit message\n- `sender` - Node ID of the sender (primary)\n- `node_id` - The node's identifier\n- `view_number` - Current view number\n- `status` - Current node status\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number\n- `commit_number` - Current commit number (before applying the new commit)\n\n---","ref":"telemetry_events.html#protocol-events"},{"type":"extras","title":"State Changes - Telemetry Events","doc":"### `[:vsr, :state, :status_change]`\n\nEmitted when a node's status changes (e.g., normal ↔ view_change).\n\n**Measurements:**\n- `count` - Always 1\n\n**Metadata:**\n- `old_status` - Previous status (`:normal`, `:view_change`, or `:uninitialized`)\n- `new_status` - New status (`:normal`, `:view_change`, or `:uninitialized`)\n- `node_id` - The node's identifier\n- `view_number` - Current view number\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number\n- `commit_number` - Current commit number\n\n### `[:vsr, :state, :commit_advance]`\n\nEmitted when the commit number advances after operations are committed.\n\n**Measurements:**\n- `operations_committed` - Number of operations committed in this batch\n\n**Metadata:**\n- `old_commit_number` - Commit number before the advancement\n- `new_commit_number` - Commit number after the advancement\n- `node_id` - The node's identifier\n- `view_number` - Current view number\n- `status` - Current node status\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number\n\n---","ref":"telemetry_events.html#state-changes"},{"type":"extras","title":"View Changes - Telemetry Events","doc":"### `[:vsr, :view_change, :start]`\n\nEmitted when a view change is initiated.\n\n**Measurements:**\n- `count` - Always 1\n\n**Metadata:**\n- `old_view` - Previous view number\n- `new_view` - New view number being transitioned to\n- `old_status` - Status before the view change\n- `node_id` - The node's identifier\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number\n- `commit_number` - Current commit number\n\n### `[:vsr, :view_change, :vote_received]`\n\nEmitted when a START-VIEW-CHANGE-ACK is received.\n\n**Measurements:**\n- `count` - Always 1\n\n**Metadata:**\n- `vote_view` - View number from the vote\n- `voter` - Node ID of the voter\n- `total_votes` - Total number of votes collected for this view\n- `node_id` - The node's identifier\n- `view_number` - Current view number\n- `status` - Current node status\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number\n- `commit_number` - Current commit number\n\n### `[:vsr, :view_change, :do_view_change, :received]`\n\nEmitted when a DO-VIEW-CHANGE message is received by the new primary.\n\n**Measurements:**\n- `count` - Always 1\n\n**Metadata:**\n- `do_view_change_view` - View number from the message\n- `sender` - Node ID of the sender\n- `sender_op_number` - Operation number from the sender's log\n- `sender_commit_number` - Commit number from the sender\n- `node_id` - The node's identifier\n- `view_number` - Current view number\n- `status` - Current node status\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number\n- `commit_number` - Current commit number\n\n### `[:vsr, :view_change, :complete]`\n\nEmitted when a view change completes and the node transitions back to normal status.\n\n**Measurements:**\n- `count` - Always 1\n\n**Metadata:**\n- `old_view` - Previous view number\n- `new_view` - New view number after completion\n- `new_status` - Status after view change (should be `:normal`)\n- `node_id` - The node's identifier\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number\n- `commit_number` - Current commit number\n\n---","ref":"telemetry_events.html#view-changes"},{"type":"extras","title":"State Machine Operations - Telemetry Events","doc":"### `[:vsr, :state_machine, :operation, :start]`\n\nEmitted when a committed operation starts execution on the state machine.\n\n**Measurements:**\n- `monotonic_time` - Monotonic time when operation execution started\n- `system_time` - System time when operation execution started\n\n**Metadata:**\n- `telemetry_span_context` - Unique reference for correlating with `:stop` event\n- `extra_op_number` - The operation number being executed\n- `operation` - String representation of the operation\n- `node_id` - The node's identifier\n- `view_number` - Current view number\n- `status` - Current node status\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number (latest in log)\n- `commit_number` - Current commit number\n\n### `[:vsr, :state_machine, :operation, :stop]`\n\nEmitted when a committed operation completes execution on the state machine.\n\n**Measurements:**\n- `monotonic_time` - Monotonic time when operation execution completed\n- `duration` - Duration of the operation execution in native time units\n\n**Metadata:**\n- `telemetry_span_context` - Same reference from the corresponding `:start` event\n- `extra_op_number` - The operation number that was executed\n- `operation` - String representation of the operation\n- `node_id` - The node's identifier\n- `view_number` - Current view number\n- `status` - Current node status\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number\n- `commit_number` - Current commit number\n\n---","ref":"telemetry_events.html#state-machine-operations"},{"type":"extras","title":"Timer Events - Telemetry Events","doc":"### `[:vsr, :timer, :heartbeat_received]`\n\nEmitted when a backup receives a heartbeat from the primary.\n\n**Measurements:**\n- `count` - Always 1\n\n**Metadata:**\n- `node_id` - The node's identifier\n- `view_number` - Current view number\n- `status` - Current node status\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number\n- `commit_number` - Current commit number\n\n### `[:vsr, :timer, :primary_timeout]`\n\nEmitted when a backup detects primary inactivity timeout.\n\n**Measurements:**\n- `count` - Always 1\n\n**Metadata:**\n- `timeout_ms` - The timeout duration in milliseconds\n- `node_id` - The node's identifier\n- `view_number` - Current view number\n- `status` - Current node status\n- `cluster_size` - Total cluster size\n- `op_number` - Current operation number\n- `commit_number` - Current commit number\n\n---","ref":"telemetry_events.html#timer-events"},{"type":"extras","title":"Common Metadata - Telemetry Events","doc":"All telemetry events include the following common metadata fields (unless otherwise noted):\n\n- `node_id` - The identifier of the node emitting the event\n- `view_number` - Current view number\n- `status` - Current node status (`:normal`, `:view_change`, or `:uninitialized`)\n- `cluster_size` - Total number of nodes in the cluster\n- `op_number` - Current operation number (highest in the log)\n- `commit_number` - Current commit number (highest committed operation)","ref":"telemetry_events.html#common-metadata"},{"type":"extras","title":"Usage Example - Telemetry Events","doc":"```elixir\n# Attach a handler to track leadership changes\n:telemetry.attach(\n  \"leadership-tracker\",\n  [:vsr, :leadership, :start],\n  fn event, measurements, metadata, _config ->\n    IO.inspect({event, measurements, metadata}, label: \"Leadership started\")\n  end,\n  nil\n)\n\n# Attach a handler to track committed operations\n:telemetry.attach(\n  \"commit-tracker\",\n  [:vsr, :state, :commit_advance],\n  fn _event, measurements, metadata, _config ->\n    IO.puts(\"Committed #{measurements.operations_committed} operations, \" <>\n            \"commit_number: #{metadata.old_commit_number} -> #{metadata.new_commit_number}\")\n  end,\n  nil\n)\n\n# Use telemetry_metrics for aggregation\nTelemetry.Metrics.counter(\"vsr.protocol.prepare.sent.count\")\nTelemetry.Metrics.distribution(\"vsr.state_machine.operation.duration\",\n  unit: {:native, :millisecond}\n)\n```","ref":"telemetry_events.html#usage-example"},{"type":"extras","title":"Integration with Monitoring Systems - Telemetry Events","doc":"These telemetry events are designed to integrate with standard Erlang/Elixir monitoring tools:\n\n- **Telemetry.Metrics** - For aggregating and reporting metrics\n- **TelemetryMetricsPrometheus** - For Prometheus integration\n- **TelemetryMetricsStatsd** - For StatsD integration\n- **Phoenix.LiveDashboard** - For real-time monitoring in Phoenix applications","ref":"telemetry_events.html#integration-with-monitoring-systems"}],"proglang":"elixir","content_type":"text/markdown","producer":{"name":"ex_doc","version":"0.39.1"}}